# Story 1.5: Initial AI Plan Generation & Display

Status: backlog

## Story

As a new user who has completed onboarding,
I want to immediately see my first AI-generated "diagnostic" workout and meal plan on my dashboard,
So I can begin my health journey.

## Acceptance Criteria

1.  **Given** I have completed the onboarding flow
2.  **When** my dashboard loads
3.  **Then** a 7-day personalized workout and meal plan is generated by the AI (Pydantic AI framework with Gemini 2.5)
4.  **And** the generated plan is displayed on the dashboard, similar to `dashboard_dark.html` (showing today's plan)
5.  **And** the plan details are stored in the database

## Requirements Context Summary

This story focuses on the initial generation and display of the user's first personalized workout and meal plan immediately after completing the onboarding process. It is a critical step in fulfilling the core value proposition of the AI Fitness & Meal Planner.

**Core User Story Statement:**
As a new user who has completed onboarding, I want to immediately see my first AI-generated "diagnostic" workout and meal plan on my dashboard, so I can begin my health journey.

**Acceptance Criteria (from Epics.md):**
1.  **Given** I have completed the onboarding flow
2.  **When** my dashboard loads
3.  **Then** a 7-day personalized workout and meal plan is generated by the AI (Pydantic AI framework with Gemini 2.5)
4.  **And** the generated plan is displayed on the dashboard, similar to `dashboard_dark.html` (showing today's plan)
5.  **And** the plan details are stored in the database

**Relevant Architectural Context (from architecture-2025-11-30.md):**
*   **AI Integration:** The backend will utilize the Pydantic AI framework with Gemini 2.5 to generate the personalized plans.
*   **AI Application Pattern:** This story directly implements steps 2 and 3 of the defined AI Application pattern:
    1.  *Collecting user data, goals, and progress* (completed in Story 1.4: Guided Onboarding Flow).
    2.  **Constructing a detailed prompt for the Pydantic AI framework with Gemini 2.5.**
    3.  **Receiving, validating, and storing the structured JSON response.**
*   **Project Structure:**
    *   **Backend:** The AI interaction logic will reside within `backend/app/services/ai_plan_generator.py`. An API endpoint (likely under `/plans/`) will be responsible for triggering plan generation.
    *   **Frontend:** The display of the generated plan will be handled by the dashboard component, expected at `frontend/src/app/(dashboard)/dashboard/page.tsx`.
*   **API Contracts:** A `/plans/` endpoint will be used for generating and retrieving the workout and meal plans. API requests and responses will be validated using Pydantic schemas.
*   **Performance:** Consideration for backend caching of AI responses (from ADR-002) may be relevant to optimize latency for plan generation, though the initial "diagnostic" plan might not benefit from caching unless similar user profiles lead to identical initial plans.
*   **Testing Strategy:** Backend tests will use `Pytest` for the `ai_plan_generator.py` service and related API endpoints. Frontend tests will use `React Testing Library` with `Jest` for the dashboard display.

**Technical Notes (from Epics.md):**
*   Backend service (`ai_plan_generator.py`) for AI interaction.
*   API endpoint to trigger plan generation.
*   Database integration to store plans.
*   Frontend integration to display on dashboard.

## Tasks / Subtasks

### Backend (`ai_plan_generator.py`, API, Database)

*   **Implement AI Plan Generation Service (`ai_plan_generator.py`)**
    *   [ ] Define Pydantic models for input (user preferences from onboarding) and output (7-day workout and meal plan structure).
    *   [ ] Implement logic to construct a detailed prompt for the Pydantic AI framework with Gemini 2.5, incorporating user's fitness goals, dietary preferences, and fitness persona.
    *   [ ] Integrate with the Gemini 2.5 API to send prompts and receive structured JSON responses.
    *   [ ] Add retry mechanisms with exponential backoff for AI API calls to enhance reliability (NFR: Reliability - AI Integration).
    *   [ ] Implement basic validation for the received AI-generated plan to ensure it conforms to expected structure.
    *   [ ] Define and implement CRUD operations for storing the generated workout and meal plans in the Supabase database.
        *   [ ] Create necessary database tables/models if not already existing (manual task due to environment limitations, as per previous story's learnings).
*   **Create API Endpoint for Plan Generation**
    *   [ ] Design and implement a `POST /api/v1/plans/generate-initial` endpoint.
    *   [ ] This endpoint should accept the user's ID or session token (via JWT) and trigger the `ai_plan_generator.py` service.
    *   [ ] Secure the endpoint using FastAPI's dependency injection for authenticated users (`Depends(get_current_user)` from `backend/app/api/v1/deps.py` - reuse from Story 1.4).
    *   [ ] Ensure the endpoint returns the generated plan or a confirmation of successful generation/storage.

### Frontend (Dashboard Integration)

*   **Integrate Dashboard with Plan Data**
    *   [ ] Modify `frontend/src/app/(dashboard)/dashboard/page.tsx` to fetch the user's initial plan upon dashboard load.
    *   [ ] Call the `POST /api/v1/plans/generate-initial` endpoint if no plan exists for the current user.
    *   [ ] Implement UI components to display the 7-day workout and meal plan.
        *   [ ] Follow UX design specifications (e.g., `dashboard_dark.html` for layout guidance).
    *   [ ] Handle loading states and error display during API calls.
    *   [ ] Ensure data is fetched and displayed for authenticated users.

### Testing

*   **Backend Unit/Integration Tests** (using `Pytest`)
    *   [ ] Test `ai_plan_generator.py` for correct prompt construction and response parsing (using mocked AI API responses).
    *   [ ] Test the `POST /api/v1/plans/generate-initial` endpoint:
        *   [ ] Verify authentication is enforced (expect 401 for unauthenticated requests).
        *   [ ] Verify correct handling of valid requests (plan generation and storage).
        *   [ ] Verify error handling (e.g., AI API failures, database errors).
        *   [ ] Mock database interactions to ensure plan storage logic is correct.
*   **Frontend Integration Tests** (using `React Testing Library` with `Jest`)
    *   [ ] Test `frontend/src/app/(dashboard)/dashboard/page.tsx` for correct rendering of plan data.
    *   [ ] Mock API calls to simulate successful plan generation and display.
    *   [ ] Verify loading indicators and error messages are displayed appropriately.
    *   [ ] Focus on the display logic, avoiding complex E2E scenarios for now.
*   **Manual Testing / User Acceptance Testing**
    *   [ ] Verify that after completing the onboarding flow, a new user sees their personalized plan on the dashboard.
    *   [ ] Confirm that the displayed plan is coherent and aligns with the preferences selected during onboarding.
    *   [ ] Check network requests to ensure API calls for plan generation and display are correctly made and data is stored.

## Project Structure Alignment and Lessons Learned

### Learnings from Previous Story (1.4: Guided Onboarding Flow)

**From Story 1.4: Guided Onboarding Flow (Status: done)**

*   **New patterns/services created**:
    *   **Frontend**: Multi-step forms (reusable components `QuestionPrompt.tsx`, `SelectionControls.tsx`), authenticated-user session handling, email verification checks. The `frontend/src/app/(auth)/onboarding/` directory structure for multi-step flows serves as a precedent for similar feature implementations.
    *   **Backend**: `PUT /api/v1/users/profile/` endpoint, Pydantic models for request validation, Supabase client initialization (`backend/app/core/supabase.py`), dependency for authenticated user (`backend/app/api/v1/deps.py`), CRUD function for user profile updates (`backend/app/crud/user.py`), FastAPI router in `backend/app/api/v1/endpoints/users.py`. These components provide a foundation for user-related data interactions.
*   **Architectural decisions and patterns to reuse**:
    *   Supabase for user authentication and data persistence.
    *   Separation of concerns between frontend (Next.js components) and backend (FastAPI endpoints, services, CRUD operations).
    *   Use of Pydantic for request/response validation in the backend.
    *   Authentication checks using Supabase JWT in both frontend and backend.
*   **Technical Debt/Warnings to consider**:
    *   The **known high-priority technical issue** with Jest + JSDOM + React Hook Form causing certain unit/integration tests to fail (`signup` and `login` test suites) was acknowledged and carried into Story 1.4. While this story might not directly involve React Hook Form, it's a general testing infrastructure limitation to be aware of. Avoidance of complex form interactions in Jest-based unit tests was recommended.
    *   Manual/external database schema management for adding fields was assumed due to environment constraints. This implies that any new database fields required for this story (e.g., to store plan details) will also need manual setup.
    *   The End-to-End (Playwright) test for the full onboarding flow is still outstanding. This highlights a gap in overall system testing that could be addressed in a future story or dedicated testing epic.
    *   No Epic Tech Spec for Epic 1 was found. This limits the ability to cross-check against detailed epic-level technical requirements, potentially leading to more ad-hoc technical decisions within stories.
*   **Files created/modified in previous story**:
    *   `frontend/src/app/(auth)/onboarding/page.tsx`
    *   `frontend/src/app/(auth)/onboarding/components/QuestionPrompt.tsx`
    *   `frontend/src/app/(auth)/onboarding/components/SelectionControls.tsx`
    *   `backend/app/api/v1/endpoints/users.py`
    *   `backend/app/api/v1/deps.py`
    *   `backend/app/schemas/user.py`
    *   `backend/app/crud/user.py`
    *   `backend/app/core/supabase.py`
    *   `frontend/src/app/(auth)/onboarding/__tests__/page.test.tsx`
    *   `backend/tests/test_users.py`
These files are crucial references for understanding existing patterns and avoiding recreation of already implemented logic. For this story, the existing `backend/app/core/supabase.py` and backend API structure will be directly reused.